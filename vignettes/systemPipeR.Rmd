---
title: "systemPipeR: Workflow and Visualization Toolkit" 
author: "Author: Daniela Cassol, Le Zhang, and Thomas Girke"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output:
  BiocStyle::html_document:
    toc_float: true
    code_folding: show
package: systemPipeR
vignette: |
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{SPR}
  %\VignetteEngine{knitr::rmarkdown}
fontsize: 14pt
bibliography: bibtex.bib
editor_options: 
  markdown: 
    wrap: 80
  chunk_output_type: console
---

```{css, echo=FALSE}
pre code {
white-space: pre !important;
overflow-x: scroll !important;
word-break: keep-all !important;
word-wrap: initial !important;
}
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
options(width = 100, max.print = 1000)
knitr::opts_chunk$set(
    eval = as.logical(Sys.getenv("KNITR_EVAL", "TRUE")),
    cache = as.logical(Sys.getenv("KNITR_CACHE", "TRUE")), 
    tidy.opts = list(width.cutoff = 100), tidy = FALSE)
```

```{r setting, echo=FALSE}
if (file.exists("spr_project")) unlink("spr_project", recursive = TRUE)
is_win <- Sys.info()[['sysname']] != "Windows"
```

```{r load_library, eval=TRUE, include=FALSE}
suppressPackageStartupMessages({
    library(systemPipeR)
})
```

# Introduction

[_`systemPipeR`_](http://www.bioconductor.org/packages/devel/bioc/html/systemPipeR.html) 
provides flexible utilities for designing, building, and running automated nd-to-end analysis 
workflows for a wide range of research applications, including next-generation 
sequencing (NGS) experiments [@H_Backman2016-bt]. Important features include a 
uniform workflow interface across different data analysis applications, automated 
report generation, and support for running both R and command-line software, 
on local computers or compute clusters (see Figure \@ref(fig:utilities)).
The latter supports interactive job submissions and batch submissions to queuing 
systems of clusters. 

It has been designed to improve the reproducibility of large-scale data analysis 
projects while substantially reducing the time it takes to analyze complex omics
data sets. Its unique features include a uniform workflow interface and management 
system that allows the user to run selected steps, customize, and design entirely
new workflows. Also, the package features take advantage of central community S4 
classes of the Bioconductor ecosystem and command-line-based software support.

The main motivation and advantages of using _`systemPipeR`_ for complex data analysis tasks are:

1. Facilitates the design of complex workflows involving multiple R/Bioconductor packages
2. Common workflow interface for different applications
3. Makes analysis with Bioconductor utilities more accessible to new users
4. Simplifies usage of command-line software from within R
5. Reduces the complexity of using compute clusters for R and command-line software
6. Accelerates runtime of workflows via parallelization on computer systems with multiple CPU cores and/or multiple compute nodes
6. Improves reproducibility by automating analyses and generation of analysis reports 

```{r utilities, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "Relevant features in `systemPipeR`. Workflow design concepts are illustrated under (A & B). Examples of *systemPipeR's* visualization functionalities are given under (C)."}
knitr::include_graphics(system.file("extdata/images", "utilities.png", package = "systemPipeR"))
```

A central concept for designing workflows within the _`systemPipeR`_ environment 
is the use of workflow management containers. 
Workflow management containers allow the automation of design, build, run and 
scale different steps and tools in data analysis.
_`systemPipeR`_ adopted the widely used community standard [Common Workflow Language](https://www.commonwl.org/) (CWL) 
[@Amstutz2016-ka] for describing parameters analysis workflows in a generic and reproducible 
manner. Using this community standard in _`systemPipeR`_
has many advantages. For instance, the integration of CWL allows running _`systemPipeR`_
workflows from a single specification instance either entirely from within R, from various command-line wrappers (e.g., *cwl-runner*) or from other languages (*, e.g.,* Bash or Python).
_`systemPipeR`_ includes support for both command-line and R/Bioconductor software 
as well as resources for containerization, parallel evaluations on computer clusters 
along with the automated generation of interactive analysis reports.

An important feature of _`systemPipeR's`_ CWL interface is that it provides two
options to run command-line tools and workflows based on CWL. First, one can
run CWL in its native way via an R-based wrapper utility for *cwl-runner* or
*cwl-tools* (CWL-based approach). Second, one can run workflows using CWL's
command-line and workflow instructions from within R (R-based approach). In the
latter case the same CWL workflow definition files (*e.g.* `*.cwl` and `*.yml`)
are used but rendered and executed entirely with R functions defined by
_`systemPipeR`_, and thus use CWL mainly as a command-line and workflow
definition format rather than software to run workflows. In this regard
_`systemPipeR`_ also provides several convenience functions that are useful for
designing and debugging workflows, such as a command-line rendering function to
retrieve the exact command-line strings for each data set and processing step
prior to running a command-line.

This overview introduces the design of a workflow management container, an S4 
class in _`systemPipeR`_, as well as the custom command-line interface, 
combined with the overview of all the common analysis steps of NGS experiments.

## New workflow management interface

_`systemPipeR`_ allows creation (multi-step analyses) and execution of workflow 
entirely for R, with control, flexibility, and scalability of the all process. 
The execution of the workflow can be sent to a HPC, can be parallelizes, 
accelerating results acquisition. 

The flexibility of _`systemPipeR's`_ new interface workflow management class is
the driving factor behind the use of as many steps necessary for the analysis,
as well as the connection between command-line- or R-based software. The
connectivity among all workflow steps is achieved by the `SYSargsList` workflow
management class.

`SYSargsList` S4 class is a list-like container where each instance stores all the
input/output paths and parameter components required for a particular data
analysis step (see Figure \@ref(fig:sysargslistImage)).

The `SYSargsList` constructor function will generate the instances, using as data 
input initial targets files, as well as two-parameter files (for details, see below).
When running preconfigured workflows, the only input the user needs to provide 
is the initial targets file containing the paths to the input files (e.g., FASTQ) 
along with unique sample labels. Subsequent targets instances are created 
automatically, based on the connectivity establish between the steps. The 
parameters required for running command-line software is provided by the 
parameter (`*.cwl` and `*.yml`)) files described below.

The class store one or multiple steps, allowing central control for running, 
checking status, and monitor complex workflows from start to finish. This design 
enhances the systemPipeR workflow framework with a generalized, flexible, and 
robust design.

```{r sysargslistImage, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "Workflow steps with input/output file operations are controlled by `SYSargs2` objects. Each `SYSargs2`instance is constructed from one targets and two param files. The only input provided by the user is the initial targets file. Subsequent targets instances are created automatically, from the previous output files. Any number of predefined or custom workflow steps are supported. One or many `SYSargs2` objects are organized in an `SYSargsList` container."}

knitr::include_graphics(system.file("extdata/images", "SPR_WF.png", package = "systemPipeR"))
```

# Quick Start

This section will demonstrate how to build a basic workflow. The main features
will be briefly illustrated here. In the next section, we will discuss all the 
alternatives to design and build the workflow and all the support features 
available in _`systemPipeR`_.

- Load sample data and directory structure

```{r genNew_wf, eval=TRUE}
systemPipeRdata::genWorkenvir(workflow = "new", mydirname = "spr_project")
```

```{r, eval=FALSE, warning=FALSE}
setwd("spr_project")
```

```{r setting_dir, include=FALSE, warning=FALSE}
knitr::opts_knit$set(root.dir = 'spr_project')
```

- Create a project

```{r SPRproject_ex, eval=TRUE}
sal_wf <- SPRproject(logs.dir = ".SPRproject_wf") 
```

- Option 1: Build workflow from R Markdown

```{r importwf_example, eval=TRUE}
sal_wf <- importWF(sal_wf, 
                    file_path = system.file("extdata", "spr_simple_wf.Rmd", package = "systemPipeR"),
                    verbose = FALSE)
```

- Option 2: Build workflow interactive
    + `Hello world!` example

```{r firstStep, eval=TRUE}
sal <- SPRproject(overwrite = TRUE) 
targetspath <- system.file("extdata/cwl/example/targets_example.txt", package = "systemPipeR")
appendStep(sal) <- SYSargsList(step_name = "echo", 
                               targets = targetspath, dir = TRUE,
                               wf_file = "example/workflow_example.cwl", input_file = "example/example.yml", 
                               dir_path = system.file("extdata/cwl", package = "systemPipeR"),
                               inputvars = c(Message = "_STRING_", SampleName = "_SAMPLE_"))
```

- Adding a R step

```{r secondStep_r, eval=TRUE}
appendStep(sal) <- LineWise(code = {
                            hello <- lapply(getColumn(sal, step = 1, 'outfiles'), function(x) yaml::read_yaml(x))
                            }, 
                            step_name = "R_getCol", 
                            dependency = "echo")
```

- Running workflow

```{r run_echo, eval=is_win}
sal <- runWF(sal)
```

- Visualize workflow

```{r plot_echo, eval=TRUE}
plotWF(sal, width = "80%", rstudio = TRUE)
```

- Checking workflow status

```{r status_echo, eval=TRUE}
statusWF(sal)
```

- Accessing logs report

```{r logs_echo, eval=FALSE}
sal <- renderLogs(sal)
```

# Getting Started

## Installation

[_`systemPipeR`_](http://www.bioconductor.org/packages/devel/bioc/html/systemPipeR.html) 
environment can be installed from the R console using the [_`BiocManager::install`_](https://cran.r-project.org/web/packages/BiocManager/index.html) 
command. The associated data package [_`systemPipeRdata`_](http://www.bioconductor.org/packages/devel/data/experiment/html/systemPipeRdata.html) 
can be installed the same way. The latter is a helper package for generating _`systemPipeR`_ 
workflow environments with a single command containing all parameter files and 
sample data required to quickly test and run workflows. 

```{r install, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE)) install.packages("BiocManager")
BiocManager::install("systemPipeR")
BiocManager::install("systemPipeRdata")
```

Please note that if you desire to use a third-party command-line tool, the particular
tool and dependencies need to be installed and exported in your PATH. 
See [details](#tools). 

## Loading package and documentation

```{r documentation, eval=FALSE}
library("systemPipeR") # Loads the package
library(help="systemPipeR") # Lists package info
vignette("systemPipeR") # Opens vignette
```

## How to get help for systemPipeR

All questions about the package or any particular function should be posted to 
the Bioconductor support site [https://support.bioconductor.org](https://support.bioconductor.org). 

Please add the "_`systemPipeR`_" tag to your question, and the package authors will 
automatically receive an alert. 

We appreciate receiving reports of bugs in the functions or documentation and
suggestions for improvement. For that, please consider opening an issue at
[GitHub](https://github.com/tgirke/systemPipeR/issues/new). 

# Project structure

_`systemPipeR`_ expects a project directory structure that consists of a directory
where users may store all the raw data, the results directory that will be reserved 
for all the outfiles files or new output folders, and the parameters directory. 

This structure allows reproducibility and collaboration across the data science 
team since internally relative paths are used. Users could transfer this project 
to a different location and still be able to run the entire workflow. Also, it 
increases efficiency and data management once the raw data is kept in a separate 
folder and avoids duplication. 

## Directory Structure {#dir}

[_`systemPipeRdata`_](http://bioconductor.org/packages/devel/data/experiment/html/systemPipeRdata.html), 
helper package, provides pre-configured workflows, reporting 
templates, and sample data loaded as demonstrated below. With a single command, 
the package allows creating the workflow environment containing the structure 
described here (see Figure \@ref(fig:dir)).

Directory names are indicated in <span style="color:grey">***green***</span>.
Users can change this structure as needed, but need to adjust the code in their 
workflows accordingly. 

* <span style="color:green">_**workflow/**_</span> (*e.g.* *myproject/*) 
    + This is the root directory of the R session running the workflow.
    + Run script ( *\*.Rmd*) and sample annotation (*targets.txt*) files are located here.
    + Note, this directory can have any name (*e.g.* <span style="color:green">_**myproject**_</span>). Changing its name does not require any modifications in the run script(s).
  + **Important subdirectories**: 
    + <span style="color:green">_**param/**_</span> 
        + <span style="color:green">_**param/cwl/**_</span>: This subdirectory stores all the parameter and configuration files. To organize workflows, each can have its own subdirectory, where all `*.cwl` and `*input.yml` files need to be in the same subdirectory. 
    + <span style="color:green">_**data/**_ </span>
        + Raw data (*e.g.* FASTQ files)
        + FASTA file of reference (*e.g.* reference genome)
        + Annotation files
        + Metadata
        + etc.
    + <span style="color:green">_**results/**_</span>
        + Analysis results are usually written to this directory, including: alignment, variant and peak files (BAM, VCF, BED); tabular result files; and image/plot files
        + Note, the user has the option to organize results files for a given sample and analysis step in a separate subdirectory.

```{r dir, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "*systemPipeR's* preconfigured directory structure."}
knitr::include_graphics(system.file("extdata/images", "spr_project.png", package = "systemPipeR"))  
```

The following parameter files are included in each workflow template:

1. *`targets.txt`*: initial one provided by user; downstream *`targets_*.txt`* files are generated automatically
2. *`*.param/cwl`*: defines parameter for input/output file operations, *e.g.*:
    + *`hisat2/hisat2-mapping-se.cwl`* 
    + *`hisat2/hisat2-mapping-se.yml`*
3. *`*_run.sh`*: optional bash scripts 
4. Configuration files for computer cluster environments (skip on single machines):
    + *`.batchtools.conf.R`*: defines the type of scheduler for *`batchtools`* pointing to template file of cluster, and located in user's home directory
    + *`batchtools.*.tmpl`*: specifies parameters of scheduler used by a system, *e.g.* Torque, SGE, Slurm, etc.

## Structure of initial _`targets`_ file

The _`targets`_ file defines all input files (_e.g._ FASTQ, BAM, BCF) and sample 
comparisons of an analysis workflow. The following shows the format of a sample 
_`targets`_ file included in the package. It also can be viewed and downloaded 
from _`systemPipeR`_'s GitHub repository [here](https://github.com/tgirke/systemPipeR/blob/master/inst/extdata/targets.txt). 
In a target file with a single type of input files, here FASTQ files of 
single-end (SE) reads, the first column describe the path and the second column
represents a unique id name for each sample. The third column called `Factor` 
represents the biological replicates. All subsequent columns are additional 
information, and any number of extra columns can be added as needed.

Users should note here, the usage of targets files is optional when using
_`systemPipeR's`_ new workflow management interface. They can be replaced by a standard YAML
input file used by CWL. Since for organizing experimental variables targets
files are extremely useful and user-friendly. Thus, we encourage users to keep using 
them. 

### Structure of _`targets`_ file for single-end (SE) samples

```{r targetsSE, eval=TRUE}
targetspath <- system.file("extdata", "targets.txt", package = "systemPipeR") 
showDF(read.delim(targetspath, comment.char = "#"))
```

To work with custom data, users need to generate a _`targets`_ file containing 
the paths to their own FASTQ files and then provide under _`targetspath`_ the
path to the corresponding _`targets`_ file. 

### Structure of _`targets`_ file for paired-end (PE) samples

For paired-end (PE) samples, the structure of the targets file is similar, where
users need to provide two FASTQ path columns: *`FileName1`* and *`FileName2`* 
with the paths to the PE FASTQ files. 

```{r targetsPE, eval=TRUE}
targetspath <- system.file("extdata", "targetsPE.txt", package = "systemPipeR")
showDF(read.delim(targetspath, comment.char = "#"))
```

### Structure of _`targets`_ file for "Hello World" example

In this example, _`targets`_ file presents only two columns, which the first one 
are the different phrases used by the `echo` command-line and the second column
it is the sample `id`. The `id` column is required, and each sample id should be unique. 

```{r targets_echo, eval=TRUE}
targetspath <- system.file("extdata/cwl/example/targets_example.txt", package = "systemPipeR")
showDF(read.delim(targetspath, comment.char = "#"))
```

### Sample comparisons

Sample comparisons are defined in the header lines of the _`targets`_ file 
starting with '``# <CMP>``'. 

```{r comment_lines, echo=TRUE}
targetspath <- system.file("extdata", "targetsPE.txt", package = "systemPipeR")
readLines(targetspath)[1:4]
```

The function _`readComp`_ imports the comparison information and stores it in a 
_`list`_. Alternatively, _`readComp`_ can obtain the comparison information from 
the corresponding _`SYSargsList`_ step (see below). Note, these header lines are 
optional. They are mainly useful for controlling comparative analyses according 
to certain biological expectations, such as identifying differentially expressed
genes in RNA-Seq experiments based on simple pair-wise comparisons.
 
```{r targetscomp, eval=TRUE}
readComp(file = targetspath, format = "vector", delim = "-")
```

## Downstream targets files description

After the step which required the initial targets file information, the downstream 
targets files are created automatically (see Figure \@ref(fig:targetsFig)).
Each step that uses the previous step outfiles as an input, the new targets input 
will be managed internally by the workflow instances, establishing connectivity 
among the steps in the workflow. 
_`systemPipeR`_ provides features to automatically and systematically build this 
connection, providing security that all the samples will be managed efficiently 
and reproducibly.

```{r targetsFig, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "_`systemPipeR`_ automatically creates the downstream `targets` files based on the previous steps outfiles. A) Usually, users provide the initial `targets` files, and this step will generate some outfiles, as demonstrated on B. Then, those files are used to build the new `targets` files as inputs in the next step. _`systemPipeR`_ (C) manages this connectivity among the steps automatically for the users."}
knitr::include_graphics(system.file("extdata/images", "targets_con.png", package = "systemPipeR"))  
```

# Structure of the new parameters files

The parameters and configuration required for running command-line software are 
provided by the widely used community standard [Common Workflow Language](https://www.commonwl.org/) (CWL) 
[@Amstutz2016-ka], which describes parameters analysis workflows in a generic 
and reproducible manner. For R-based workflow steps, param files are not required. 
For a complete overview of the CWL syntax, please see the [section](#cwl) below. 
Also, we have a dedicated section explain how to _`systemPipeR`_ establish the 
connection between the CWL parameters files and the targets files. Please see [here](#cwl_targets). 

```{r cleaning, eval=TRUE, include=FALSE}
if (file.exists(".SPRproject")) unlink(".SPRproject", recursive = TRUE)
## NOTE: Removing previous project create in the quick starts section
```

# Project initialization

To create a Workflow within _`systemPipeR`_, we can start by defining an empty
container and checking the directory structure:

```{r SPRproject, eval=TRUE}
sal <- SPRproject(projPath = getwd()) 
```

Internally, `SPRproject` function will create a hidden folder called `.SPRproject`,
by default, to store all the log files.
A `YAML` file, here called `SYSargsList.yml`, has been created, which initially
contains the basic location of the project structure; however, every time the 
workflow object `sal` is updated in R, the new information will also be store in this 
flat-file database for easy recovery.
If you desire different names for the logs folder and the `YAML` file, these can 
be modified as follows:

```{r SPRproject_logs, eval=FALSE}
sal <- SPRproject(logs.dir= ".SPRproject", sys.file=".SPRproject/SYSargsList.yml") 
```

Also, this function will check and/or create the basic folder structure if missing, 
which means `data`, `param`, and `results` folder, as described [here](#dir). 
If the user wants to use a different names for these directories, can be specified 
as follows:

```{r SPRproject_dir, eval=FALSE}
sal <- SPRproject(data = "data", param = "param", results = "results") 
```

It is possible to separate all the R objects created within the workflow analysis 
from the current environment. `SPRproject` function provides the option to create 
a new environment, and in this way, it is not overwriting any object you may want
to have at your current section. 

```{r SPRproject_env, eval=FALSE}
sal <- SPRproject(envir = new.env()) 
```

In this stage, the object `sal` is a empty container, except for the project information. The project information can be accessed by the `projectInfo` method:

```{r projectInfo, eval=TRUE}
sal
projectInfo(sal)
```

Also, the `length` function will return how many steps this workflow contains and
in this case it is empty, as follow:

```{r length, eval=TRUE}
length(sal)
```

# Workflow Design 

_`systemPipeR`_ workflows can be designed and built from start to finish with a 
single command, importing from an R Markdown file or stepwise in interactive 
mode from the R console. 
In the [next section](#appendstep), we will demonstrate how to build the workflow in an
interactive mode, and in the [following section](#importWF), we will show how to build from a 
file. 

New workflows are constructed, or existing ones modified, by connecting each 
step via `appendStep` method. Each `SYSargsList` instance contains instructions 
needed for processing a set of input files with a specific command-line or R 
software, as well as the paths to the corresponding outfiles generated by a 
particular tool/step. 

To build R code based step, the constructor function `Linewise` is used. 
For more details about this S4 class container, see [here](#linewise). 

## Build workflow interactive {#appendstep}

This tutorial shows a very simple example for describing and explaining all main 
features available within systemPipeR to design, build, manage, run, and 
visualize the workflow. In summary, we are exporting a dataset to multiple 
files, compressing and decompressing each one of the files, and importing to R, 
and finally performing a statistical analysis. 

In the previous section, we initialize the project by building the `sal` object.
Until this moment, the container has no steps:

```{r sal_check, eval=TRUE}
sal
```

Next, we need to populate the object created with the first step in the
workflow.

### Adding the first step 

The first step is R code based, and we are splitting the `iris` dataset by `Species`
and for each `Species` will be saved on file. Please note that this code will
not be executed now; it is just store in the container for further execution. 

This constructor function requires the `step_name` and the R-based code under 
the `code` argument. 
The R code should be enclosed by braces (`{}`) and separated by a new line. 

```{r, firstStep_R, eval=TRUE}
appendStep(sal) <- LineWise(code = {
                              mapply(function(x, y) write.csv(x, y),
                                     split(iris, factor(iris$Species)),
                                     file.path("results", paste0(names(split(iris, factor(iris$Species))), ".csv"))
                                     ) 
                            },
                            step_name = "export_iris")
```

For a brief overview of the workflow, we can check the object as follows:

```{r show, eval=TRUE}
sal
```

Also, for printing and double-check the R code in the step, we can use the 
`codeLine` method:

```{r codeLine, eval=TRUE}
codeLine(sal)
```

### Adding more steps

Next, an example of how to compress the exported files using 
[`gzip`](https://www.gnu.org/software/gzip/) command-line. 

The constructor function creates an `SYSargsList` S4 class object using data from
three input files:

    - CWL command-line specification file (`wf_file` argument);
    - Input variables (`input_file` argument);
    - Targets file (`targets` argument).

In CWL, files with the extension `.cwl` define the parameters of a chosen
command-line step or workflow, while files with the extension `.yml` define the
input variables of command-line steps. 

The `targets` file is optional for workflow steps lacking `input` files. The connection 
between `input` variables and the `targets` file is defined under the `inputvars` 
argument. It is required a `named vector`, where each element name needs to match
with column names in the `targets` file, and the value must match the names of 
the `input` variables defined in the `*.yml` files (see Figure \@ref(fig:sprCWL)). 

A detailed description of the dynamic between `input` variables and `targets` 
files can be found [here](#cwl_targets). 
In addition, the CWL syntax overview can be found [here](#cwl). 

Besides all the data form `targets`, `wf_file`, `input_file` and `dir_path` arguments,
`SYSargsList` constructor function options include: 

  - `step_name`: a unique *name* for the step. This is not mandatory; however, 
    it is highly recommended. If no name is provided, a default `step_x`, where
    `x` reflects the step index, will be added. 
  - `dir`: this option allows creating an exclusive subdirectory for the step 
    in the workflow. All the outfiles and log files for this particular step will 
    be generated in the respective folders.
  - `dependency`: after the first step, all the additional steps appended to 
    the workflow require the information of the dependency tree. 

The `appendStep<-` method is used to append a new step in the workflow.

```{r gzip_secondStep, eval=TRUE}
targetspath <- system.file("extdata/cwl/gunzip", "targets_gunzip.txt", package = "systemPipeR")
appendStep(sal) <- SYSargsList(step_name = "gzip", 
                      targets = targetspath, dir = TRUE,
                      wf_file = "gunzip/workflow_gzip.cwl", input_file = "gunzip/gzip.yml",
                      dir_path = system.file("extdata/cwl", package = "systemPipeR"),
                      inputvars = c(FileName = "_FILE_PATH_", SampleName = "_SampleName_"), 
                      dependency = "export_iris")
```

Note: This will not work if the `gzip` is not available on your system 
(installed and exported to PATH) and may only work on Windows systems using PowerShell. 

For a overview of the workflow, we can check the object as follows:

```{r}
sal
```

Note that we have two steps, and it is expected three files from the second step.
Also, the workflow status is *Pending*, which means the workflow object is 
rendered in R; however, we did not execute the workflow yet. 
In addition to this summary, it can be observed this step has three command lines. 

For more details about the command-line rendered for each target file, it can be 
checked as follows: 

```{r}
cmdlist(sal, step="gzip")
```

#### Using the `outfiles` for the next step

For building this step, all the previous procedures are being used to append the 
next step. However, here, we can observe power features that build the 
connectivity between steps in the workflow.

In this example, we would like to use the outfiles from *gzip* Step, as
input from the next step, which is the *gunzip*. In this case, let's look at the 
outfiles from the first step:

```{r}
outfiles(sal)
```

The column we want to use is "gzip_file". For the argument `targets` in the 
`SYSargsList` function, it should provide the name of the correspondent step in
the Workflow and which `outfiles` you would like to be incorporated in the next 
step. 
The argument `inputvars` allows the connectivity between `outfiles` and the 
new `targets` file. Here, the name of the previous `outfiles` should be provided 
it. Please note that all `outfiles` column names must be unique.

It is possible to keep all the original columns from the `targets` files or remove
some columns for a clean `targets` file.
The argument `rm_targets_col` provides this flexibility, where it is possible to
specify the names of the columns that should be removed. If no names are passing
here, the new columns will be appended. 

```{r gunzip, eval=TRUE}
appendStep(sal) <- SYSargsList(step_name = "gunzip", 
                      targets = "gzip", dir = TRUE,
                      wf_file = "gunzip/workflow_gunzip.cwl", input_file = "gunzip/gunzip.yml",
                      dir_path = system.file("extdata/cwl", package = "systemPipeR"),
                      inputvars = c(gzip_file = "_FILE_PATH_", SampleName = "_SampleName_"), 
                      rm_targets_col = "FileName", 
                      dependency = "gzip")
```

We can check the targets automatically create for this step, 
based on the previous `outfiles`:

```{r targetsWF_3, eval=TRUE}
targetsWF(sal[3])
```

We can also check all the expected `outfiles` for this particular step, as follows:

```{r outfiles_2, eval=TRUE}
outfiles(sal[3])
```

Now, we can observe that the third step has been added and contains one substep.

```{r}
sal
```

In addition, we can access all the command lines for each one of the substeps. 

```{r, eval=TRUE}
cmdlist(sal["gzip"], targets = 1)
```

#### Getting data from a workflow instance 

The final step in this simple workflow is an R code step. For that, we are using
the `LineWise` constructor function as demonstrated above. 

One interesting feature showed here is the `getColumn` method that allows 
extracting the information for a workflow instance. Those files can be used in
an R code, as demonstrated below. 

```{r getColumn, eval=TRUE}
getColumn(sal, step = "gunzip", 'outfiles')
```

```{r, iris_stats, eval=TRUE}
appendStep(sal) <- LineWise(code = {
                    df <- lapply(getColumn(sal, step = "gunzip", 'outfiles'), function(x) read.delim(x, sep = ",")[-1])
                    df <- do.call(rbind, df)
                    stats <- data.frame(cbind(mean = apply(df[,1:4], 2, mean), sd = apply(df[,1:4], 2, sd)))
                    stats$species <- rownames(stats)
                    
                    plot <- ggplot2::ggplot(stats, ggplot2::aes(x = species, y = mean, fill = species)) + 
                      ggplot2::geom_bar(stat = "identity", color = "black", position = ggplot2::position_dodge()) +
                      ggplot2::geom_errorbar(ggplot2::aes(ymin = mean-sd, ymax = mean+sd), width = .2, position = ggplot2::position_dodge(.9)) 
                    },
                    step_name = "iris_stats", 
                    dependency = "gzip")
```

## Build workflow from a {R Markdown} {#importWF}

The precisely same workflow can be created by importing the steps from an 
R Markdown file.
As demonstrated above, it is required to initialize the project with `SPRproject` function. 

`importWF` function will scan and import all the R chunk from the R Markdown file 
and build all the workflow instances. Then, each R chuck in the file will be 
converted in a workflow step. 

```{r importWF_rmd, eval=TRUE}
sal_rmd <- SPRproject(logs.dir = ".SPRproject_rmd") 

sal_rmd <- importWF(sal_rmd, 
                file_path = system.file("extdata", "spr_simple_wf.Rmd", package = "systemPipeR"))
```

Let's explore the workflow to check the steps:

```{r importWF_details}
stepsWF(sal_rmd)
dependency(sal_rmd)
codeLine(sal_rmd)
targetsWF(sal_rmd)
```

### Rules to create the R Markdown to import as workflow

To include a particular code chunk from the R Markdown file in the workflow
analysis, please use the following code chunk options:

    - `spr='r'`: for code chunks with R code lines;
    - `spr='sysargs'`: for code chunks with an `SYSargsList` object;
    - `spr.dep=<StepName>`: for specify the previous dependency.

For example: 

> *```{r step_1, eval=TRUE, spr='r', spr.dep='step_0'}*

> *```{r step_2, eval=TRUE, spr='sysargs', spr.dep='step_1'}*

For `spr = 'sysargs'`, the last object assigned must to be the `SYSargsList`, for example:

```{r fromFile_example_rules, eval=TRUE, spr='sysargs'}
targetspath <- system.file("extdata/cwl/example/targets_example.txt", package = "systemPipeR")
HW_mul <- SYSargsList(step_name = "Example", 
                      targets = targetspath, 
                      wf_file = "example/example.cwl", input_file = "example/example.yml", 
                      dir_path = system.file("extdata/cwl", package = "systemPipeR"), 
                      inputvars = c(Message = "_STRING_", SampleName = "_SAMPLE_"))
```

Also, note that all the required files or objects to generate one particular 
command-line step must be defined in a R code chunk imported. 
The motivation for this is that when R Markdown files are imported, the 
`spr = 'sysargs'` R chunk will be evaluated and stored in the workflow control 
class as the `SYSargsList` object, while the R code based (`spr = 'r'`) is not 
evaluated, and until the workflow is executed it will be store as an expression.

# Running the workflow

For running the workflow, `runWF` function will execute all the command lines 
store in the workflow container.

```{r runWF, eval=is_win}
sal <- runWF(sal)
```

This essential function allows the user to choose one or multiple steps to be 
executed using the `steps` argument. However, it is necessary to follow the 
workflow dependency graph. If a selected step depends on a previous step(s) that
was not executed, the execution will fail. 

```{r runWF_error, eval=FALSE}
sal <- runWF(sal, steps = c(1,3))
```

Also, it allows forcing the execution of the steps, even if the status of the 
step is `'Success'` and all the expected `outfiles` exists. 
Another feature of the `runWF` function is ignoring all the warnings 
and errors and running the workflow by the arguments `warning.stop` and 
`error.stop`, respectively.

```{r runWF_force, eval=FALSE}
sal <- runWF(sal, force = TRUE, warning.stop = FALSE, error.stop = TRUE)
```

When the project was initialized by `SPRproject` function, it was created an 
environment for all objects created during the workflow execution. This 
environment can be accessed as follows:

```{r runWF_env, eval=FALSE}
viewEnvir(sal)
```

The workflow execution allows to save this environment for future recovery:

```{r runWF_saveenv, eval=FALSE}
sal <- runWF(sal, saveEnv = TRUE)
```

## Workflow status

To check the summary of the workflow, we can use:

```{r show_statusWF, eval=TRUE}
sal
```

To access more details about the workflow instances, we can use the `statusWF` method:

```{r statusWF, eval=TRUE}
statusWF(sal)
```

## Parallelization on clusters

This section of the tutorial provides an introduction to the usage of the 
_`systemPipeR`_ features on a cluster.

The computation can be greatly accelerated by processing many files 
in parallel using several compute nodes of a cluster, where a scheduling/queuing
system is used for load balancing. For this the `clusterRun` function submits 
the computing requests to the scheduler using the run specifications
defined by `runWF`. 

A named list provides the computational resources. By default, it can be defined
the upper time limit in minutes for jobs before they get killed by the scheduler, 
memory limit in Mb, number of `CPUs`, and number of tasks. 

The number of independent parallel cluster processes is defined under the
`Njobs` argument. The following example will run one process in parallel using 
for each 4 CPU cores. If the resources available on a cluster allow running all 
the processes simultaneously, then the shown sample submission will utilize in 
total four CPU cores (`NJobs * ncpus`). Note, `clusterRun` can be used
with most queueing systems as it is based on utilities from the _`batchtools`_ 
package which supports the use of template files (_`*.tmpl`_) for defining the 
run parameters of different schedulers. To run the following code, one needs to 
have both a `conf file` (see _`.batchtools.conf.R`_ samples [here](https://mllg.github.io/batchtools/)) 
and a template file (see _`*.tmpl`_ samples [here](https://github.com/mllg/batchtools/tree/master/inst/templates)) 
for the queueing available on a system. The following example uses the sample 
`conf` and `template` files for the `Slurm` scheduler provided by this package.  

```{r clusterRun, eval=FALSE}
library(batchtools)
resources <- list(walltime=120, ntasks=1, ncpus=4, memory=1024)
sal <- clusterRun(sal, FUN = runWF, 
                  more.args = list(),
                  conffile=".batchtools.conf.R", 
                  template="batchtools.slurm.tmpl",
                  Njobs=1, runid="01", resourceList=resources)
```

Note: The example is submitting the jog to `short` partition. If you desire to 
use a different partition, please adjust accordingly (`batchtools.slurm.tmpl`).

# Visualize workflow

_`systemPipeR`_ workflows instances can be visualized with the `plotWF` function.

This function will make a plot of selected workflow instance and the following 
information is displayed on the plot:

    - Workflow structure (dependency graphs between different steps); 
    - Workflow step status, *e.g.* `Success`, `Error`, `Pending`, `Warnings`; 
    - Sample status and statistics; 
    - Workflow timing: running duration time. 

If no argument is provided, the basic plot will automatically detect width, 
height, layout, plot method, branches, _etc_. 

```{r, eval=TRUE}
plotWF(sal, show_legend = TRUE, width = "80%", rstudio = TRUE)
```

For more details about the `plotWF` function, please see [here](#plotWF).

# Technical report

_`systemPipeR`_ compiles all the workflow execution logs in one central location, 
making it easier to check any standard output (`stdout`) or standard error 
(`stderr`) for any command-line tools used on the workflow or the R code `stdout`.
Also, the workflow plot is appended at the beginning of the report, making it 
easier to click on the respective step.

```{r, eval=FALSE}
sal <- renderLogs(sal)
```

# Exported the workflow 

_`systemPipeR`_ workflow management system allows to translate and export the 
workflow build interactively to R Markdown format or an executable bash script.
This feature advances the reusability of the workflow, as well as the flexibility
for workflow execution.

## R Markdown file

`sal2rmd` function takes an `SYSargsList` workflow container and translates it to 
SPR workflow template R markdown format. This file can be imported with the 
`importWF` function, as demonstrated above.

```{r, eval=FALSE}
sal2rmd(sal)
```

## Bash script

`sal2bash` function takes an `SYSargsList` workflow container and translates 
it to an executable bash script, so one can run the workflow without loading 
`SPR` or using an R console.


```{r, eval=FALSE}
sal2bash(sal)
```

It will be generated on the project root an executable bash script, called by
default the `spr_wf.sh`. Also, a directory `./spr_wf` will be created and store 
all the R scripts based on the workflow steps. Please note that this function will 
"collapse" adjacent R steps into one file as much as possible.

# Project Resume and Restart

If you desire to resume or restart a project that has been initialized in the past, 
`SPRproject` function allows this operation.

With the resume option, it is possible to load the `SYSargsList` object in R and 
resume the analysis. Please, make sure to provide the `logs.dir` location, and the 
corresponded `YAML` file name.
The current working directory needs to be in the project root directory.

```{r SPR_resume, eval=FALSE}
sal <- SPRproject(resume = TRUE, logs.dir = ".SPRproject", 
                  sys.file = ".SPRproject/SYSargsList.yml") 
```

If you choose to save the environment in the last analysis, you can recover all 
the files created in that particular section. `SPRproject` function allows this 
with `load.envir` argument. Please note that the environment was saved only with
you run the workflow in the last section (`runWF()`).

```{r resume_load, eval=FALSE}
sal <- SPRproject(resume = TRUE, load.envir = TRUE) 
```

After loading the workflow at your current section, you can check the objects 
created in the old environment and decide if it is necessary to copy them to the
current environment.

```{r envir, eval=FALSE}
viewEnvir(sal)
copyEnvir(sal, list="plot", new.env = globalenv())
```

This option will keep all previous logs in the folder; however, if you desire to 
clean the execution history and restart the workflow, the `restart=TRUE` option
can be used.

```{r restart_load, eval=FALSE}
sal <- SPRproject(restart = TRUE, overwrite = TRUE, load.envir = FALSE) 
```

The last and more drastic option from `SYSproject` function is to overwrite the
logs and the workflow. This option will delete the hidden folder and the 
information on the `SYSargsList.yml` files. This will not delete any parameter
file nor any results it was created in previous runs. Please use with caution. 

```{r SPR_overwrite, eval=FALSE}
sal <- SPRproject(overwrite = TRUE) 
```

# Exploring workflow instances {#sysargslist}

_`systemPipeR`_ provide several accessor methods and useful functions to explore 
`SYSargsList` workflow object.

## Accessor Methods

Several accessor methods are available that are named after the slot names of
the `SYSargsList` workflow object.

```{r}
names(sal)
```

- Check the length of the workflow:

```{r}
length(sal)
```

- Check the steps of the workflow:

```{r}
stepsWF(sal)
```

- Checking the command-line for each target sample:

`cmdlist()` method printing the system commands for running command-line
software as specified by a given `*.cwl` file combined with the paths to the
input samples (*e.g.* FASTQ files) provided by a `targets` file. The example below
shows the `cmdlist()` output for running `gzip` and `gunzip` on the first sample. 
Evaluating the output of `cmdlist()` can be very helpful for designing
and debugging `*.cwl` files of new command-line software or changing the
parameter settings of existing ones.

```{r}
cmdlist(sal, step = c(2,3), targets = 1)
```

- Check the workflow status:

```{r}
statusWF(sal)
```

- Check the workflow targets files:

```{r}
targetsWF(sal[2])
```

- Checking the expected outfiles files:

The `outfiles` components of `SYSargsList` define the expected outfiles files 
for each step in the workflow, some of which are the input for the next workflow step.

```{r}
outfiles(sal[2])
```

- Check the workflow dependencies:

```{r}
dependency(sal)
```

- Check the sample comparisons:

Sample comparisons are defined in the header lines of the `targets` file 
starting with '``# <CMP>``'. This information can be accessed as follows:

```{r, eval=FALSE}
targetsheader(sal, step = "Quality")
```

- Get the workflow steps names: 

```{r}
stepName(sal)
```

- Get the Sample Id for on particular step:

```{r}
SampleName(sal, step = "gzip")
SampleName(sal, step = "iris_stats")
```

- Get the `outfiles` or `targets` column files: 

```{r}
getColumn(sal, "outfiles", step = "gzip", column = "gzip_file")
getColumn(sal, "targetsWF", step = "gzip", column = "FileName")
```

- Get the R code for a `LineWise` step:

```{r}
codeLine(sal, step = "export_iris")
```

- View all the objects in the running environment:

```{r}
viewEnvir(sal)
```

- Copy one or multiple objects from the running environment to a new environment:

```{r}
copyEnvir(sal, list = c("plot"), new.env = globalenv(), silent = FALSE)
```

- Accessing the `*.yml` data

```{r}
yamlinput(sal, step = "gzip")
```

## Subsetting the workflow details

- The `SYSargsList` class and its subsetting operator `[`:

```{r}
sal[1]
sal[1:3]
sal[c(1,3)]
```

- The `SYSargsList` class and its subsetting by steps and input samples: 

```{r}
sal_sub <- subset(sal, subset_steps = c( 2,3), input_targets = ("SE"), keep_steps = TRUE)
stepsWF(sal_sub)
targetsWF(sal_sub)
outfiles(sal_sub)
```

- The `SYSargsList` class and its operator `+`

```{r, eval=FALSE}
sal[1] + sal[2] + sal[3]
```

## Replacement Methods

- Update a `input` parameter in the workflow

```{r, eval=TRUE}
sal_c <- sal
## check values
yamlinput(sal_c, step = "gzip")
## check on command-line
cmdlist(sal_c, step = "gzip", targets = 1)
## Replace
yamlinput(sal_c, step = "gzip", paramName = "ext") <- "txt.gz"

## check NEW values
yamlinput(sal_c, step = "gzip")
## Check on command-line
cmdlist(sal_c, step = "gzip", targets = 1)
```

- Append and Replacement methods for R Code Steps

```{r, sal_lw_rep, eval=TRUE}
appendCodeLine(sal_c, step = "export_iris", after = 1) <- "log_cal_100 <- log(100)"
codeLine(sal_c, step = "export_iris")

replaceCodeLine(sal_c, step="export_iris", line = 2) <- LineWise(code={
                    log_cal_100 <- log(50)
                    })
codeLine(sal_c, step = 1)
```

For more details about the `LineWise` class, please see [below](#linewise).

- Rename a Step

```{r}
renameStep(sal_c, step = 1) <- "newStep"
renameStep(sal_c, c(1, 2)) <- c("newStep2", "newIndex")
sal_c
names(outfiles(sal_c))
names(targetsWF(sal_c))
dependency(sal_c)
```

- Replace a Step

```{r, eval=FALSE}
sal_test <- sal[c(1,2)]
replaceStep(sal_test, step = 1, step_name = "gunzip" ) <- sal[3]
sal_test
```

Note: Please use this method with attention, because it can disrupt all 
the dependency graphs. 

- Removing a Step

```{r}
sal_test <- sal[-2]
sal_test
```

# CWL syntax {#cwl}

This section will introduce how CWL describes command-line tools and the 
specification and terminology of each file. 
For complete documentation, please check the CommandLineTools documentation [here](https://www.commonwl.org/v1.2/CommandLineTool.html) 
and [here](https://www.commonwl.org/v1.2/Workflow.html) for Workflows and the user guide [here](https://www.commonwl.org/user_guide/). 

CWL command-line specifications are written in [YAML](http://yaml.org/) format.

In CWL, files with the extension `.cwl` define the parameters of a chosen 
command-line step or workflow, while files with the extension `.yml` define 
the input variables of command-line steps. 

## CWL `CommandLineTool`

`CommandLineTool` by CWL definition is a standalone process, with no interaction 
if other programs, execute a program, and produce output. 

Let's explore the `*.cwl` file: 

```{r}
dir_path <- system.file("extdata/cwl", package = "systemPipeR")
cwl <- yaml::read_yaml(file.path(dir_path, "example/example.cwl"))
```

- The `cwlVersion` component shows the CWL specification version used by the document. 
- The `class` component shows this document describes a `CommandLineTool.`
Note that CWL has another `class`, called `Workflow` which represents a union of one 
or more command-line tools together. 

```{r}
cwl[1:2]
```

- `baseCommand` component provides the name of the software that we desire to execute.

```{r}
cwl[3]
```

- The `inputs` section provides the input information to run the tool. Important 
components of this section are: 
    - `id`: each input has an id describing the input name;
    - `type`: describe the type of input value (string, int, long, float, double, 
    File, Directory or Any);
    - `inputBinding`: It is optional. This component indicates if the input 
    parameter should appear on the command-line. If this component is missing 
    when describing an input parameter, it will not appear in the command-line 
    but can be used to build the command-line.

```{r}
cwl[4]
```

- The `outputs` section should provide a list of the expected outputs after running the command-line tools. Important 
components of this section are: 
    - `id`: each input has an id describing the output name;
    - `type`: describe the type of output value (string, int, long, float, double, 
    File, Directory, Any or `stdout`);
    - `outputBinding`: This component defines how to set the outputs values. The `glob` component will define the name of the output value. 

```{r}
cwl[5]
```

- `stdout`: component to specify a `filename` to capture standard output.
Note here we are using a syntax that takes advantage of the inputs section, 
using results_path parameter and also the `SampleName` to construct the output `filename.` 

```{r}
cwl[6]
```

## CWL `Workflow`

`Workflow` class in CWL is defined by multiple process steps, where can have 
interdependencies between the steps, and the output for one step can be used as 
input in the further steps.

```{r}
cwl.wf <- yaml::read_yaml(file.path(dir_path, "example/workflow_example.cwl"))
```

- The `cwlVersion` component shows the CWL specification version used by the document. 
- The `class` component shows this document describes a `Workflow`.

```{r}
cwl.wf[1:2]
```

- The `inputs` section describes the inputs of the workflow.

```{r}
cwl.wf[3]
```

- The `outputs` section describes the outputs of the workflow.

```{r}
cwl.wf[4]
```

- The `steps` section describes the steps of the workflow. In this simple example, 
we demonstrate one step.

```{r}
cwl.wf[5]
```

## CWL Input Parameter 

Next, let's explore the *.yml* file, which provide the input parameter values for all
the components we describe above. 

For this simple example, we have three parameters defined:

```{r}
yaml::read_yaml(file.path(dir_path, "example/example_single.yml"))
```

Note that if we define an input component in the *.cwl* file, this value needs 
to be also defined here in the *.yml* file. 

# How to connect CWL description files within _`systemPipeR`_ {#cwl_targets}

This section will demonstrate how to connect CWL parameters files to create 
workflows. In addition, we will show how the workflow can be easily scalable 
with _`systemPipeR`_.

`SYSargsList` container stores all the information and instructions needed for processing 
a set of input files with a single or many command-line steps within a workflow 
(i.e. several components of the software or several independent software tools). 
The `SYSargsList` object is created and fully populated with the `SYSargsList` construct
function. 
Full documentation of `SYSargsList` management instances can be found [here](#sysargslist)
and [here](#appendstep).

The following imports a `.cwl` file (here `example.cwl`) for running the `echo Hello World!` 
example.

```{r fromFile, eval=TRUE}
HW <- SYSargsList(wf_file = "example/workflow_example.cwl", 
                  input_file = "example/example_single.yml", 
                  dir_path = system.file("extdata/cwl", package = "systemPipeR"))
HW
cmdlist(HW)
```

However, we are limited to run just one command-line or one sample in this example. 
To scale the command-line over many samples, a simple solution offered by `systemPipeR` 
is to provide a `variable` for each of the parameters that we want to run with multiple samples. 

Let's explore the example:

```{r}
yml <- yaml::read_yaml(file.path(dir_path, "example/example.yml"))
yml
```

For the `message` and `SampleName` parameter, we are passing a variable connecting 
with a third file called `targets.` 

Now, let's explore the `targets` file structure:

```{r}
targetspath <- system.file("extdata/cwl/example/targets_example.txt", package = "systemPipeR")
read.delim(targetspath, comment.char = "#")
```

The `targets` file defines all input files or values and sample ids of an analysis workflow. 
For this example, we have defined a string message for the `echo` command-line tool,
in the first column that will be evaluated, and the second column is the 
`SampleName` id for each one of the messages.
Any number of additional columns can be added as needed.

Users should note here, the usage of `targets` files is optional when using 
`systemPipeR's` new CWL interface. Since for organizing experimental variables targets 
files are extremely useful and user-friendly. Thus, we encourage users to keep using them.

### How to connect the parameter files and `targets` file information?

The constructor function creates an `SYSargsList` S4 class object connecting three input files:

  - CWL command-line specification file (`wf_file` argument);
  - Input variables (`input_file` argument);
  - Targets file (`targets` argument).
    
As demonstrated above, the latter is optional for workflow steps lacking input files. 
The connection between input variables (here defined by `input_file` argument) 
and the `targets` file are defined under the `inputvars` argument. 
A named vector is required, where each element name needs to match with column 
names in the `targets` file, and the value must match the names of the *.yml* 
variables. This is used to replace the CWL variable and construct all the command-line
for that particular step. 

The variable pattern `_XXXX_` is used to distinguish CWL variables that target 
columns will replace. This pattern is recommended for consistency and easy identification
but not enforced.

The following imports a `.cwl` file (same example demonstrated above) for running
the `echo Hello World` example. However, now we are connecting the variable defined 
on the `.yml` file with the `targets` file inputs.

```{r fromFile_example, eval=TRUE}
HW_mul <- SYSargsList(step_name = "echo", 
                      targets=targetspath, 
                      wf_file="example/workflow_example.cwl", input_file="example/example.yml", 
                      dir_path = dir_path, 
                      inputvars = c(Message = "_STRING_", SampleName = "_SAMPLE_"))
HW_mul
cmdlist(HW_mul)
```

```{r sprCWL, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "WConnectivity between CWL param files and targets files."}
knitr::include_graphics(system.file("extdata/images", "SPR_CWL_hello.png", package = "systemPipeR"))
```

# Creating the CWL param files from the command-line

Users need to define the command-line in a pseudo-bash script format:

```{r cmd, eval=TRUE}
command <- "
    hisat2 \
    -S <F, out: ./results/M1A.sam> \
    -x <F: ./data/tair10.fasta> \
     -k <int: 1> \
    -min-intronlen <int: 30> \
    -max-intronlen <int: 3000> \
    -threads <int: 4> \
    -U <F: ./data/SRR446027_1.fastq.gz>
"
```

## Define prefix and defaults

- First line is the base command. Each line is an argument with its default value.

- For argument lines (starting from the second line), any word before the first 
  space with leading `-` or `--` in each will be treated as a prefix, like `-S` or 
  `--min`. Any line without this first word will be treated as no prefix. 
  
- All defaults are placed inside `<...>`.

- First argument is the input argument type. `F` for "File", "int", "string" are unchanged.

- Optional: use the keyword `out` followed the type with a `,` comma separation to 
  indicate if this argument is also an CWL output.
  
- Then, use `:` to separate keywords and default values, any non-space value after the `:`
  will be treated as the default value. 
  
- If any argument has no default value, just a flag, like `--verbose`, there is no need to add any `<...>`

## `createParam` Function

`createParam` function requires the `string` as defined above as an input. 

First of all, the function will print the three components of the `cwl` file:
    - `BaseCommand`: Specifies the program to execute. 
    - `Inputs`: Defines the input parameters of the process.
    - `Outputs`: Defines the parameters representing the output of the process.
    
The four component is the original command-line.

If in interactive mode, the function will verify that everything is correct and 
will ask you to proceed. Here, the user can answer "no" and provide more 
information at the string level. Another question is to save the param created here.

If running the workflow in non-interactive mode, the `createParam` function will 
consider "yes" and returning the container.

```{r}
cmd <- createParam(command, writeParamFiles = FALSE)
```

If the user chooses not to save the `param` files on the above operation, 
it can use the `writeParamFiles` function.

```{r saving, eval=FALSE}
writeParamFiles(cmd, overwrite = TRUE)
```

## How to access and edit param files

### Print a component

```{r}
printParam(cmd, position = "baseCommand") ## Print a baseCommand section
printParam(cmd, position = "outputs")
printParam(cmd, position = "inputs", index = 1:2) ## Print by index
printParam(cmd, position = "inputs", index = -1:-2) ## Negative indexing printing to exclude certain indices in a position
```

### Subsetting the command-line

```{r}
cmd2 <- subsetParam(cmd, position = "inputs", index = 1:2, trim = TRUE)
cmdlist(cmd2)

cmd2 <- subsetParam(cmd, position = "inputs", index = c("S", "x"), trim = TRUE)
cmdlist(cmd2)
```

### Replacing a existing argument in the command-line

```{r}
cmd3 <- replaceParam(cmd, "base", index = 1, replace = list(baseCommand = "bwa"))
cmdlist(cmd3)
```

```{r}
new_inputs <- new_inputs <- list(
    "new_input1" = list(type = "File", preF="-b", yml ="myfile"),
    "new_input2" = "-L <int: 4>"
)
cmd4 <- replaceParam(cmd, "inputs", index = 1:2, replace = new_inputs)
cmdlist(cmd4)
```

### Adding new arguments

```{r}
newIn <- new_inputs <- list(
    "new_input1" = list(type = "File", preF="-b1", yml ="myfile1"),
    "new_input2" = list(type = "File", preF="-b2", yml ="myfile2"),
    "new_input3" = "-b3 <F: myfile3>"
)
cmd5 <- appendParam(cmd, "inputs", index = 1:2, append = new_inputs)
cmdlist(cmd5)

cmd6 <- appendParam(cmd, "inputs", index = 1:2, after=0, append = new_inputs)
cmdlist(cmd6)
```

### Editing `output` param

```{r}
new_outs <- list(
    "sam_out" = "<F: $(inputs.results_path)/test.sam>"
) 
cmd7 <- replaceParam(cmd, "outputs", index = 1, replace = new_outs)
output(cmd7) 
```

### Internal Check

```{r sysargs2, eval=TRUE}
cmd <- "
    hisat2 \
    -S <F, out: _SampleName_.sam> \
    -x <F: ./data/tair10.fasta> \
    -k <int: 1> \
    -min-intronlen <int: 30> \
    -max-intronlen <int: 3000> \
    -threads <int: 4> \
    -U <F: _FASTQ_PATH1_>
"
WF <- createParam(cmd, overwrite = TRUE, writeParamFiles = TRUE, confirm = TRUE) 
targetspath <- system.file("extdata", "targets.txt", package = "systemPipeR")
WF_test <- loadWorkflow(targets = targetspath, wf_file="hisat2.cwl",
                   input_file="hisat2.yml", dir_path = "param/cwl/hisat2/")
WF_test <- renderWF(WF_test, inputvars = c(FileName = "_FASTQ_PATH1_"))
WF_test
cmdlist(WF_test)[1:2]
```

# Visualize Workflow - Full details {#plotWF}

## Color and text

On the plot, different colors and numbers indicate different status. This information 
can be found also in the plot legends.

**Shapes:**

- circular steps: pure R code steps
- rounded squares steps: `sysargs` steps, steps that will invoke command-line calls
- blue colored steps and arrows: main branch (see [main branch](#main-branch) section below)

**Step colors**

- black: pending steps
- <span class="text-success">Green</span>: successful steps
- <span class="text-danger">Green</span>: failed steps

**Number and colors**

<br>There are 4 numbers in the second row of each step, separated by `/`

- <span class="text-success">First No.</span>: number of passed samples
- <span class="text-warning">Second No.</span>: number of warning samples
- <span class="text-danger">Third No.</span>: number of erros samples
- <span style="color:blue;">Forth No.</span>: number of total samples

**Duration**

<br>This is shown after the sample information, as how long it took to run this step. 
Units are a few seconds (**s**), some minutes (**m**), or some hours (**h**). 

## on hover

When the mouse is hovering on each step, detailed information will be displayed.

## logging

The workflow steps will also become clickable if `in_log = TRUE`. This will create links 
for each step that navigate to corresponding log section in the SPR 
[workflow log file](change to page that introduce the log file). Normally this option 
is handled by SPR log file generating function to create this plot on top of the log file,
so when a certain step is click, it will navigate to the detailed section down the page. 
Here is only an example to demo how the plot can be clickable (will not navigate you to 
anywhere). Visit [this page](link) to see a real example. 

```{r}
plotWF(sal, in_log = TRUE)
```

## Plot Method

The default plotting method is `svg`. It means the plot is generated by `svg` embedding. 
Sometimes certain browsers may not display `svg` correctly. In this case, the other option 
is to use `png` to embed the plot. However, you will **lose hovering, clicking and some** 
**responsiveness** (plot auto resizing ability) of the plot. 

```{r}
plotWF(sal, plot_method = "png")
```

## Rstudio

By default, even if you are working inside Rstudio the plot is **not displayed in Rstudio viewer**. 
This is because the workflow steps will be too small inside Rstudio viewer too 
see the details. We recommend to view it in a larger space, so by default it will 
open up your web browser to display it. You can enforce `rstudio = TRUE` to see it 
in Rstudio Viewer. 

```{r}
plotWF(sal, rstudio = TRUE)
```

## Responsiveness

This is a term often used in web development. It means will the plot resize itself 
if the user resize the document window? By default, `plotWF` will be responsive, 
meaning it will fit current window container size and adjust the size once the window 
size has changed. To always display the full sized plot, use `responsive = FALSE`,
useful for embedding the plot in a full-screen mode.

<div style="height: 500px">
```{r}
plotWF(sal, responsive = FALSE)
```
</div>

For the plot above, you need to scroll to see the plot.

## Layout

There a few different layout you can choose. There is no best layout. It all depends 
on the workflow structure you have. The default is `compact` but we recommend you 
to try different layouts to find the best fitting one. 

- `compact`: try to plot steps as close as possible.
- `vertical`: main branch will be placed vertically and side branches will be placed
  on the same horizontal level and sub steps of side branches will be placed
  vertically.
- `horizontal`: main branch is placed horizontally and side branches and sub
  steps will be placed vertically.
- `execution`: a linear plot to show the workflow execution order of all steps.

**vertical**

```{r}
plotWF(sal, layout = "vertical", height = "600px")
```
The plot is very long, use `height` to make it smaller.

**horizontal**

```{r}
plotWF(sal, layout = "horizontal")
```

**execution**

```{r}
plotWF(sal, layout = "execution", height = "600px", responsive = FALSE)
```

The plot is very long but if we use `height` to limit to a smaller size, details are 
hard to see. Then it will be good to use `height` and `responsive = FALSE` together. 

## Main branch 

From the plots above, you can that there are many steps which do not connect to any 
other steps. These dead-ends are called ending steps. If we connect the first step,
steps in between and these ending step, this will become a branch. Imagine the workflow is 
a upside-down tree structure and the root is the first step. Therefore, there are 
many possible ways to connect the workflow. For the convenience of plotting, we 
introduce a concept of _"main branch"_, meaning one of the possible connecting 
strategies that will be placed at the center of the plot. Other steps that are not 
in this major branch will surround this major space. 

This main branch will not impact the `compact` layout so much but will have a huge 
effect on `horizontal` and `vertical` layouts. 

The plotting function has an algorithm that will automatically choose a best branch for 
you by default. In simple words, it favors: a. branches that connect first and last step;
b. as long as possible. 

You can also choose a branch you want by `branch_method = "choose"`. It will first 
list all possible branches, and then give you a prompt to ask for your favorite branch. 
Here, for rendering the Rmarkdown, we cannot have a prompt, so we use a second argument 
in combination, `branch_no = x` to directly choose a branch and skip the prompt. Also, 
we use the `verbose = TRUE` to imitate the branch listing in console. In a real case, 
you only need `branch_method = "choose"`.

Watch closely how the plot change by choosing different branches. Here we use `vertical`
layout to demo. Remember, the main branch is marked in blue. 

```{r collapse=TRUE}
plotWF(sal, layout = "vertical", branch_method = "choose", branch_no = 1, verbose = FALSE)
```

### Unmark main branch 

The _main branch_ concept may not represent the main workflow. It is introduced 
for the convenience of plotting. Most times by auto detecting, it will find the 
major steps in a workflows, sometimes it does not. It depends on how the users 
design the workflow. If you think this is not a good representation, you can mute it 
by `mark_main_branch = FALSE`. You will no longer see the blue-colored steps on 
plot and on legends. 

```{r}
plotWF(sal, mark_main_branch = FALSE, height = "500px")
```

## Legends 

The legend can also be removed by `show_legend = FALSE`

```{r}
plotWF(sal, show_legend = FALSE, height = "500px")
```

## Output formats 

There are current three output formats: `"html"` and `"dot"`, `"dot_print"`. If first 
two were chosen, you also need provide a path `out_path` to save the file. 

- html: a single html file contains the plot.
- dot: a DOT script file with the code to reproduce the plot in a [graphiz](https://graphviz.org/)
  DOT engine. 
- dot_print: directly cat the dot script to console. 

```{r}
plotWF(sal, out_format = "html", out_path = "example_out.html")
file.exists("example_out.html")
```

```{r}
plotWF(sal, out_format = "dot", out_path = "example_out.dot")
cat(readLines("example_out.dot")[1:5], sep = "\n")
```

```{r eval=FALSE}
plotWF(sal, out_format = "dot_print") #
```

### Save to a static image file

Some users may want to save the plot to a static image, like `.png` format. We will 
need do some extra work to save the file. The reason we cannot directly save it to 
a png file is the plot is generated in real-time by a browser javascript engine. It 
requires one type of javascript engine, like Chrome, MS Edge, Viewer in Rstudio,
to render the plot before we can see it.

#### Interactive 

- If you are working in Rstudio, you can use the `export` button in the viewer to save 
an image file. 
- If you are working from command-line, use `plot_method = 'png'` to first ask the browser
  to generate a png and then when you see the image, you can right-click to save it. 
  
#### Non-interactive

If you cannot have an interactive session, like submitting a job to a cluster, 
but still want the png, we recommend to use the {[webshot2](https://github.com/wch/webshot)}
package to screenshot the plot. It runs headless Chrome in the back-end (which has a javascript engine).

Install the package 

```{r eval=FALSE}
# remotes::install_github("rstudio/webshot2")
```

Save to html first

```{r eval=FALSE}
#plotWF(sal, out_format = "html", out_path = "example_out.html")
# file.exists("example_out.html")
```

Use `webshot2` to save the image

```{r}
# webshot2::webshot("example_out.html", "example_out.png")
```

# Inner Classes

`SYSargsList` steps are can be defined with two inner classes, `SYSargs2` and
`LineWise`. Next, more details on both classes.

## `SYSargs2` Class {#sysargs2}

*`SYSargs2`* workflow control class, an S4 class, is a list-like container where
each instance stores all the input/output paths and parameter components
required for a particular data analysis step. *`SYSargs2`* instances are
generated by two constructor functions, *loadWF* and *renderWF*, using as data
input *targets* or *yaml* files as well as two *cwl* parameter files (for
details see below).

In CWL, files with the extension *`.cwl`* define the parameters of a chosen
command-line step or workflow, while files with the extension *`.yml`* define
the input variables of command-line steps. Note, input variables provided by a
*targets* file can be passed on to a *`SYSargs2`* instance via the *inputvars*
argument of the *renderWF* function.

The following imports a *`.cwl`* file (here *`hisat2-mapping-se.cwl`*) for
running the short read aligner HISAT2 [@Kim2015-ve]. For more details about the
file structure and how to design or customize our own software tools, please
check `systemPipeR and CWL` pipeline.

```{r sysargs2_cwl_structure, echo = FALSE, eval=FALSE}
hisat2.cwl <- system.file("extdata", "cwl/hisat2/hisat2-mapping-se.cwl", package = "systemPipeR")
yaml::read_yaml(hisat2.cwl)
```

```{r sysargs2_yaml_structure, echo = FALSE, eval=FALSE}
hisat2.yml <- system.file("extdata", "cwl/hisat2/hisat2-mapping-se.yml", package = "systemPipeR")
yaml::read_yaml(hisat2.yml)
```

The *loadWF* and *renderWF* functions render the proper command-line strings for
each sample and software tool.

```{r SYSargs2_structure, eval=TRUE}
library(systemPipeR)
targetspath <- system.file("extdata", "targets.txt", package = "systemPipeR")
dir_path <- system.file("extdata/cwl", package = "systemPipeR")
WF <- loadWF(targets = targetspath, wf_file = "hisat2/hisat2-mapping-se.cwl",
                   input_file = "hisat2/hisat2-mapping-se.yml",
                   dir_path = dir_path)

WF <- renderWF(WF, inputvars = c(FileName = "_FASTQ_PATH1_", 
                                 SampleName = "_SampleName_"))
```

Several accessor methods are available that are named after the slot names of
the *`SYSargs2`* object.

```{r names_WF, eval=TRUE}
names(WF)
```

Of particular interest is the *`cmdlist()`* method. It constructs the system
commands for running command-line software as specified by a given *`.cwl`* file
combined with the paths to the input samples (*e.g.* FASTQ files) provided by a
*`targets`* file. The example below shows the *`cmdlist()`* output for running
HISAT2 on the first SE read sample. Evaluating the output of *`cmdlist()`* can
be very helpful for designing and debugging *`.cwl`* files of new command-line
software or changing the parameter settings of existing ones.

```{r cmdlist, eval=TRUE}
cmdlist(WF)[1]
```

The output components of *`SYSargs2`* define the expected output files for each
step in the workflow; some of which are the input for the next workflow step,
here next *`SYSargs2`* instance.

```{r output_WF, eval=TRUE}
output(WF)[1]
```

The targets components of `SYSargs2` object can be accessed by the targets
method. Here, for single-end (SE) samples, the structure of the targets file is
defined by:

- `FileName`: specify the FASTQ files path;
- `SampleName`: Unique IDs for each sample;
- `Factor`: ID for each treatment or condition.

```{r, targets_WF, eval=TRUE}
targets(WF)[1]
as(WF, "DataFrame")
```

Please note, to work with custom data, users need to generate a *`targets`* file
containing the paths to their own FASTQ files and then provide under
*`targetspath`* the path to the corresponding *`targets`* file.

In addition, if the [Environment Modules](http://modules.sourceforge.net/) is
available, it is possible to define which module should be loaded, as shown
here:

```{r, module_WF, eval=TRUE}
modules(WF)
```

Additional information can be accessed, as the parameters files location and the
`inputvars` provided to generate the object.

```{r, other_WF, eval=FALSE}
files(WF)
inputvars(WF)
```

## LineWise Class {#linewise}

`LineWise` was designed to store all the R code chunk when an RMarkdown file is
imported as a workflow.

```{r lw, eval=TRUE}
rmd <- system.file("extdata", "spr_simple_lw.Rmd", package = "systemPipeR")
sal_lw <- SPRproject(overwrite = TRUE)
sal_lw <- importWF(sal_lw, rmd, verbose = FALSE)
codeLine(sal_lw)
```

- Coerce methods available:

```{r, lw_coerce, eval=TRUE}
lw <- stepsWF(sal_lw)[[2]]
## Coerce
ll <- as(lw, "list")
class(ll)
lw <- as(ll, "LineWise")
lw
```

- Access details

```{r, lw_access, eval=TRUE}
length(lw)
names(lw)
codeLine(lw)
codeChunkStart(lw)
rmdPath(lw)
```

- Subsetting

```{r, lw_sub, eval=TRUE}
l <- lw[2]
codeLine(l)
l_sub <- lw[-2]
codeLine(l_sub)
```

- Replacement methods

```{r, lw_rep, eval=TRUE}
replaceCodeLine(lw, line = 2) <- "5+5"
codeLine(lw)
appendCodeLine(lw, after = 0) <- "6+7"
codeLine(lw)
```

- Replacement methods for `SYSargsList`

```{r, sal_rep_append, eval=FALSE}
replaceCodeLine(sal_lw, step = 2, line = 2) <- LineWise(code={
                                                             "5+5"
                                                                })
codeLine(sal_lw, step = 2)

appendCodeLine(sal_lw, step = 2) <- "66+55"
codeLine(sal_lw, step = 2)

appendCodeLine(sal_lw, step = 1, after = 1) <- "66+55"
codeLine(sal_lw, step = 1)
```

## Workflow design structure using *`SYSargs`*: Previous version

Instances of this S4 object class are constructed by the *`systemArgs`* function
from two simple tabular files: a *`targets`* file and a *`param`* file. The
latter is optional for workflow steps lacking command-line software. Typically,
a *`SYSargs`* instance stores all sample-level inputs as well as the paths to
the corresponding outputs generated by command-line- or R-based software
generating sample-level output files, such as read preprocessors
(trimmed/filtered FASTQ files), aligners (SAM/BAM files), variant callers
(VCF/BCF files) or peak callers (BED/WIG files). Each sample level input/output
operation uses its own *`SYSargs`* instance. The outpaths of *`SYSargs`* usually
define the sample inputs for the next *`SYSargs`* instance. This connectivity is
established by writing the outpaths with the *`writeTargetsout`* function to a
new *`targets`* file that serves as input to the next *`systemArgs`* call.
Typically, the user has to provide only the initial *`targets`* file. All
downstream *`targets`* files are generated automatically. By chaining several
*`SYSargs`* steps together one can construct complex workflows involving many
sample-level input/output file operations with any combination of command-line
or R-based software.

```{r, eval=TRUE, echo=FALSE, out.width="100%", fig.align = "center", fig.cap= "Workflow design structure of *`systemPipeR`* using previous version of *`SYSargs`*"}
knitr::include_graphics(system.file("extdata/images", "SystemPipeR_Workflow.png", package = "systemPipeR"))  
```

# Third-party software tools {#tools}

Current, *systemPipeR* provides the _`param`_ file templates for third-party 
software tools. Please check the listed software tools. 

```{r table_tools, echo=FALSE, message=FALSE}
library(magrittr)
SPR_software <- system.file("extdata", "SPR_software.csv", package = "systemPipeR")
software <- read.delim(SPR_software, sep = ",", comment.char = "#")
colors <- colorRampPalette((c("darkseagreen", "indianred1")))(length(unique(software$Category)))
id <- as.numeric(c((unique(software$Category))))
software %>%
  dplyr::mutate(Step = kableExtra::cell_spec(Step, color = "white", bold = TRUE,
    background = factor(Category, id, colors)
  )) %>%
   dplyr::select(Tool, Description, Step) %>%
  dplyr::arrange(Tool) %>% 
  kableExtra::kable(escape = FALSE, align = "c", col.names = c("Tool Name",	"Description", "Step")) %>%
  kableExtra::kable_styling(c("striped", "hover", "condensed"), full_width = TRUE) %>%
  kableExtra::scroll_box(width = "80%", height = "500px")
```

Remember, if you desire to run any of these tools, make sure to have the 
respective software installed on your system and configure in the `PATH`. 
You can check as follows: 

```{r test_tool_path, eval=FALSE}
tryCMD(command="gzip") 
```

# Version information

```{r sessionInfo}
sessionInfo()
```

# Funding

This project is funded by NSF award [ABI-1661152](https://www.nsf.gov/awardsearch/showAward?AWD_ID=1661152). 

# References
